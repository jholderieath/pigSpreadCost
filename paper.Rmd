---
title: "Potential Welfare Impacts From the Continued Spread of Wild Pigs"
output: html_notebook
---
```{r echo=TRUE}
#options(expressions = 5e5)
library(h2o)
library(tidyverse)
library(readxl)
#library(rSymPy)
library(maps)
library(reticulate)
library(choroplethr)
library(choroplethrMaps)
library(triangle)
h2o.no_progress()
source('edm_fx.R')
#data(state.fips)
```

# Abstract
Wild Pigs are spreading across the United States and bringing damage with them. Damage estimates from a survey of producers reported 2014 crop losses of $190 million in 11 US states (Anderson et al. 2016), and associated short-run welfare losses were calculated at $142 million (Holderieath et al. 2018). With approximately 80% of corn, 78% of soybeans, 62% of wheat, 6% of rice, and 1% of peanuts produced in counties that do not have wild pigs, there is a substantial amount of production at risk in the event of continued spread. Preliminary results from an equilibrium displacement model of those crops suggest that if wild pigs inflict a relatively small amount of damage in all counties they are not currently present in, consumer surplus will suffer by $1.154 billion and producer surplus netting a gain of $423 million. McClure et al. (2015) and Snow et al. (2017) have demonstrated that wild pigs can survive in much of the US; however, not all US counties are equally likely to be invaded. This work will integrate the probability of wild pig invasion to find the likely welfare effects of wild pigs continuing to spread.

# Introduction

Invasive wild pigs, also known as feral swine and wild boars were introduced to the Southeastern United States in the 16th century by Spanish explorers (Keiter, Mayer, and Beasley 2016). Wild pig presence can be costly as they are known to carry diseases dangerous to humans and livestock, depredate and compete for resources with native wildlife and damage property. Total damages have been estimated at $800 million per year (Pimentel, Zuniga, and Morrison 2005). Direct production losses to corn, soybeans, wheat, rice, and peanuts in ten of the affected states were estimated at $190 million per year through a producer survey (Anderson et al. 2016). There is more to be considered than simple production losses. Production losses will affect prices, which will affect consumers and producers who do not experience damage. Net short-run welfare losses due to wild pig damage to corn, soybeans, wheat, rice, and peanuts were calculated at $142 million (Holderieath et al. 2018). However, three of those crops are primarily grown outside of the counties that have wild pigs. If wild pigs continue to spread, that absence may be short-lived.
In recent years, wild pigs are spreading at an increasing rate across the continental United States. Over the thirty years between 1982 and 2012, the northward rate of expansion was 8.9 kilometers per year, and the yearly average rate of northward expansion from 2009 to 2012 was 12.6 kilometers per year  (Snow, Jarzyna, and VerCauteren 2017). Building on the methods of Snow, Jarzyna, and VerCauteren (2017) and Holderieath et al. (2018) we pair an ecological model of the probability of spreading wild pigs with an economic model of crop damage to estimate the potential for welfare losses if wild pigs continue their northward spread.

# Methods
Our basic approach is to estimate a similar model to Snow, Jarzyna, and VerCauteren (2017) with many of the same regressors and with the same end of predicting the probability of invasion in a period. However, we take a different approach to estimation, discussed in the next subsection. In year timesteps over the next thirty years, counties are randomly presented for a new infestation of wild pigs. Newly present wild pigs will then affect the probability of neighboring counties when they are presented. In this way, the probability of spread is a function of the presence of wild pigs in neighboring and nearby counties in addition to regressors such as weather and land use. Once counties have been presented for invasion, a random level of damage from a triangle distribution described in a later subsection is imposed. In modern times wild pigs are rarely removed from a county, so the simulation does not provide for that. Once wild pigs are present, they remain present for the duration of the simulation. Each county’s production is sent to a national market, and price changes are calculated with an equilibrium displacement model. Welfare measures are calculated as compensating variation and production losses. 

## Probability of Invasion
Snow, Jarzyna, and VerCauteren (2017) used an openBUGS (Bayesian inference Using Gibbs Sampling) model (OpenBUGS 2018) implemented in R (R Core Team 2018) for their prediction of wild pig territory expansion. Spatio-temporal presence data is available (Lutman 2013; Snow, Jarzyna, and VerCauteren 2017), however, the intervals are not even and the data does not specify absence, only presence. Any attempt to use this data as a panel data set for estimation of spread will encounter both spatial and temporal non-stationarity. The non-stationarity should be expected because spatial nearness to wild pigs is one of the best predictors of presence of wild pigs. The time steps are uneven and eradication is rarely observed leading to suspicion over the time dimension. These problems could be corrected to find a consistent estimator (e.g., a within or first differences model). However, maybe another approach is warranted. 

The problem at hand is essentially an ecological classification problem. Are wild pigs known to be present? This type of problem has been addressed with a machine learning method known as Random Forest (RF) (Cutler et al. 2007; Walsh et al. 2017). One particularly attractive characteristic of this approach is the lack of reliance on distributional assumptions (Cutler et al. 2007; Walsh et al. 2017). At its most simple, the software builds numerous weighted decision trees and uses those trees to predict an outcome. The intuition of decision trees is also attractive as we can see the importance of variables on the predictions and understand that distance to the nearest known population of wild pigs is an important predictor of wild pig presence, for example (Cook 2017).

Data from the online appendix of Snow, Jarzyna, and VerCauteren (2017) was reshaped to standard panel format with variables in columns and observations across time in rows. Variables for precipitation, stream distance, road miles, and land-use were used in the analysis, however, variables about temperature were dropped due to an apparent loss of prediction accuracy. Temperature is highly correlated with latitude and the RF appeared to put too much weight on those variables, reducing accuracy in predicting presence in later time periods as wild pigs move north. A more spatially direct modeling technique would not need data on distance to nearest known wild pigs because it would be implicit in the model. Adopting the RF approach meant a need to know how far wild pigs are from a given county (that is not itself). Distance between each county within 500 miles (Roth 2014) was combined with wild pig presence data (Lutman 2013) to create a minimum distance to wild pigs from each county variable to pair with the reshaped Snow, Jarzyna, and VerCauteren (2017) data.

```{r snow_and_pig_data, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# Snow et al data import
SNOW <- read_csv("SNOW.csv") 
# Recode expansion variable
SNOW$EXPAND <- recode(SNOW$EXPAND, '1' = 'present', '0' = 'present')
SNOW$EXPAND <- replace_na(SNOW$EXPAND, "unknown")
SNOW$GEOID <- str_pad(SNOW$GEOID, 5, side = "left", pad = "0")
# split Snow by time period
snow_1 <- SNOW %>% filter(TIME == 1)
snow_2 <- SNOW %>% filter(TIME == 2)
snow_3  <- SNOW %>% filter(TIME == 3)
snow_4  <- SNOW %>% filter(TIME == 4)
# import wild pig presence
PigsIn2012 <- unique(read_excel("PigsIn2012.xlsx"))
PigsIn2004 <- unique(read_excel("PigsIn2004.xlsx"))
PigsIn1988<- unique(read_excel("PigsIn1988.xlsx"))
PigsIn1982 <- unique(read_excel("PigsIn1982.xlsx"))
# import county distance data
sf12010countydistancemiles_csv <- read_csv("sf12010countydistance500miles.csv.zip")
# join distances to presence
countyPigs <- left_join(by = c('county2' = 'FIPS') , sf12010countydistancemiles_csv, PigsIn2012)
countyPigs <- left_join(by = c('county2' = 'FIPS') , countyPigs, PigsIn2004)
countyPigs <- left_join(by = c('county2' = 'FIPS') , countyPigs, PigsIn1988)
countyPigs <- left_join(by = c('county2' = 'FIPS') , countyPigs, PigsIn1982)
# recode fips codes update to match snow et al
countyPigs <- subset(countyPigs,county1 != '51515' | county2 != '51515'| county1 != '46113' | county2 != '46113')
#countyPigs <- subset(countyPigs,)
# countyPigs$county1 <- ifelse(countyPigs$county1 == '51515',c('51019'), c(countyPigs$county1))
# countyPigs$county2 <- ifelse(countyPigs$county2 == '51515',c('51019'), c(countyPigs$county2))
# countyPigs$county1 <- ifelse(countyPigs$county1 == '46113',c('46102'), c(countyPigs$county1))
# countyPigs$county2 <- ifelse(countyPigs$county2 == '46113',c('46102'), c(countyPigs$county2))

by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_1982 == 1) %>%
  filter(mi_to_county == min(mi_to_county))

snow_1 <- left_join(by = c('GEOID' = 'county1') , snow_1, by_cty[,c("county1","mi_to_county","county2")])
snow_1$mi_to_county <- replace_na(snow_1$mi_to_county, 500)

by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_1988 == 1) %>%
  filter(mi_to_county == min(mi_to_county))

snow_2 <- left_join(by = c('GEOID' = 'county1') , snow_2, by_cty[,c("county1","mi_to_county","county2")])
snow_2$mi_to_county <- replace_na(snow_2$mi_to_county, 500)


by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_2004 == 1) %>%
  filter(mi_to_county == min(mi_to_county))

snow_3 <- left_join(by = c('GEOID' = 'county1') , snow_3, by_cty[,c("county1","mi_to_county","county2")])
snow_3$mi_to_county <- replace_na(snow_3$mi_to_county, 500)


by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_2012 == 1) %>%
  filter(mi_to_county == min(mi_to_county))

snow_4 <- left_join(by = c('GEOID' = 'county1') , snow_4, by_cty[,c("county1","mi_to_county","county2")])
snow_4$mi_to_county <- replace_na(snow_4$mi_to_county, 500)

SNOW <- bind_rows(snow_1,snow_2,snow_3,snow_4)
rm(snow_1,snow_2,snow_3,snow_4)

SNOW <- left_join(by = c('GEOID' = 'FIPS') , SNOW, PigsIn1982)
SNOW <- left_join(by = c('GEOID' = 'FIPS') , SNOW, PigsIn1988)
SNOW <- left_join(by = c('GEOID' = 'FIPS') , SNOW, PigsIn2004)
SNOW <- left_join(by = c('GEOID' = 'FIPS') , SNOW, PigsIn2012)

```


A software product, H2O (Cook 2017), was used to implement the RF in R (R Core Team 2018). Training was carried out on the periods 1982-1988, 1988-2004, and 2009-2012. Validation was carried out using a Cross-Validation method with fifty folds. The model was able to predict presence or unknown with approximately nine percent errors. The model was tested with the period 2004-2009 with slightly higher errors of approximately ten percent.

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
train_tbl <- SNOW %>% filter(TIME == 1 | TIME == 2| TIME == 3)
#valid_tbl <- SNOW %>% filter(TIME == 2)
test_tbl  <- SNOW %>% filter(TIME == 4)

h2o.init(nthreads = -1) # Fire up h2o
factorsList <- c("GEOID", "ECO_DIVISN", "TIME", "EXPAND", 'county2', 
                 "Id_2012", "Id_2004", "Id_1988", "Id_1982")
# Convert to H2OFrame objects
train_h2o <- as.h2o(train_tbl)
train_h2o[,factorsList] <- as.factor(train_h2o[,factorsList])

#valid_h2o <- as.h2o(valid_tbl)
#valid_h2o[,factorsList] <- as.factor(valid_h2o[,factorsList])

test_h2o  <- as.h2o(test_tbl)
test_h2o[,factorsList] <- as.factor(test_h2o[,factorsList])

y <- "EXPAND"

x <-  c("AREA_KM", "ECO_DIVISN", "mammal.richness",  
        "P_Ag", "P_Dev", "P_For", "P_Oth", "P_Ran", "P_Wat", "P_Wet",
        "A_MN_Ag", "A_MN_Dev", "A_MN_For", "A_MN_Oth", "A_MN_Ran", "A_MN_Wat", "A_MN_Wet",
        "A_CV_Ag", "A_CV_Dev", "A_CV_For", "A_CV_Oth", "A_CV_Ran", "A_CV_Wat", "A_CV_Wet",
        "PD", "AREA_AM", "AREA_CV", "CWED", "CONTAG", "IJI", "DIVISION", "SIDI",
        "AI", 
        "Annual_Precip", "Summer_Precip", "Winter_Precip", "maxPrecip", "minPrecip",
        "STREAM_KM", "ROAD_KM", "HumanPop", 
        "precipsum", "precipwin", "popdes.slope", "mi_to_county")

#"Annual_Temp", "Summer_Temp", "Winter_Temp", "maxTemp", "minTemp","tmaxmean", "tmaxmax", "tminmean", "tminmin",


m <- h2o.randomForest(x,y,train_h2o, nfolds = 50, model_id = "RF_defaults",keep_cross_validation_predictions = FALSE)
#summary(m)
m
mt <- h2o.performance(m, test_h2o)
mt
```


## Spatio-temporal Simulation of Spread
With estimated an estimated probability of invasion function, counties are evaluated for the probability of invasion in random order, without replacement. The RF model developed in the previous section is used to evaluate iteratively updated data on wild pig presence. Random presentation, rather than south to north is an attempt to simulate human introduction. The county’s probability of invasion is evaluated, then a random draw from u(0…1) is compared to the probability of invasion. If the probability is greater than the draw, the county is invaded and its status is updated for all subsequent counties evaluated in that time-step. Time-steps were set at an attempt to average the wildly varying spans of time between the observation points of 1982, 1988, 2004, and 2012. Predicted observations were set for 2020, 2028, and 2036 for a long-term outlook on the problem.

```{r}
# incorporate predictions to snow data--------------
SIM <- as.data.frame(h2o.predict(m,test_h2o))
SIM <- bind_cols(filter(SNOW, TIME == 4),SIM)

#generate random numbers to compare against prediction
SIM <- SIM %>%
  add_column(random_2020 = runif(nrow(SIM),min = 0, max = 1))%>%
  add_column(random_2028 = runif(nrow(SIM),min = 0, max = 1))%>%
  add_column(random_2036 = runif(nrow(SIM),min = 0, max = 1))


#Time Step 1: 2020
SIM$Id_2020 <- with(SIM, ifelse(is.na(Id_2012),
                                ifelse(random_2020 < present, 1, NA),
                                1))

#update machine learning dependent var
SIM$EXPAND <- with(SIM, ifelse(is.na(Id_2020),
                               "unknown",
                               "present"))
#update distance to nearest
countyPigs <- left_join(by = c('county2' = 'GEOID') , countyPigs, SIM[,c('GEOID','Id_2020')])# join distances to presence
by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_2020 == 1) %>%
  filter(mi_to_county == min(mi_to_county))

SIM <- left_join(by = c('GEOID' = 'county1') , SIM, by_cty[,c('county1',"mi_to_county",
                                                              "county2")])
SIM$county2.x <- SIM$mi_to_county.x <- NULL
SIM <- rename(SIM,mi_to_county = mi_to_county.y)
SIM <- rename(SIM,county2 = county2.y)
SIM$mi_to_county <- replace_na(SIM$mi_to_county, 500)

#Time Step 2: 2028
SIMh <- as.h2o(SIM)
REPEAT <- as.data.frame(h2o.predict(m,SIMh))
SIM <- bind_cols(SIM, REPEAT)

SIM$Id_2028 <- with(SIM, ifelse(is.na(Id_2020),
                                ifelse(random_2028 < present1, 1, NA),
                                1))
#update machine learning dependent var
SIM$EXPAND <- with(SIM, ifelse(is.na(Id_2028),
                               "unknown",
                               "present"))
#update distance to nearest
countyPigs <- left_join(by = c('county2' = 'GEOID') , countyPigs, SIM[,c('GEOID','Id_2028')])# join distances to presence
by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_2028 == 1) %>%
  filter(mi_to_county == min(mi_to_county))
SIM <- left_join(by = c('GEOID' = 'county1') , SIM, by_cty[,c('county1',"mi_to_county",
                                                              "county2")])
SIM$county2.x <- SIM$mi_to_county.x <- NULL
SIM <- rename(SIM,mi_to_county = mi_to_county.y)
SIM <- rename(SIM,county2 = county2.y)
SIM$mi_to_county <- replace_na(SIM$mi_to_county, 500)




#Time Step 3: 2036
SIMh <- as.h2o(SIM)
REPEAT <- as.data.frame(h2o.predict(m,SIMh))
SIM <- bind_cols(SIM, REPEAT)

SIM$Id_2036 <- with(SIM, ifelse(is.na(Id_2028),
                                ifelse(random_2036 < present2, 1, NA),
                                1))
#update machine learning dependent var
SIM$EXPAND <- with(SIM, ifelse(is.na(Id_2036),
                               "unknown",
                               "present"))
#update distance to nearest
countyPigs <- left_join(by = c('county2' = 'GEOID') , countyPigs, SIM[,c('GEOID','Id_2036')])# join distances to presence
by_cty <- countyPigs %>% group_by(county1)%>% 
  filter(Id_2036 == 1) %>%
  filter(mi_to_county == min(mi_to_county))
SIM <- left_join(by = c('GEOID' = 'county1') , SIM, by_cty[,c('county1',"mi_to_county",
                                                              "county2")])
SIM$county2.x <- SIM$mi_to_county.x <- NULL
SIM <- rename(SIM,mi_to_county = mi_to_county.y)
SIM <- rename(SIM,county2 = county2.y)
SIM$mi_to_county <- replace_na(SIM$mi_to_county, 500)


#Time Step 4: 2042
# SIMh <- as.h2o(SIM)
# REPEAT <- as.data.frame(h2o.predict(m,SIMh))
# SIM <- bind_cols(SIM, REPEAT)
# SIM$random <- runif(1,min = 0, max = 1)
# SIM$Id_2042 <- with(SIM, ifelse(is.na(Id_2036),
#                                 ifelse(random < present3, 1, NA),
#                                 1))
# #update machine learning dependent var
# SIM$EXPAND <- with(SIM, ifelse(is.na(Id_2042),
#                                "unknown",
#                                "present"))
# #update distance to nearest
# countyPigs <- left_join(by = c('county2' = 'GEOID') , countyPigs, SIM[,c('GEOID','Id_2042')])# join distances to presence
# by_cty <- countyPigs %>% group_by(county1)%>% 
#   filter(Id_2042 == 1) %>%
#   filter(mi_to_county == min(mi_to_county))
# SIM <- left_join(by = c('GEOID' = 'county1') , SIM, by_cty[,c('county1',"mi_to_county",
#                                                               "county2")])
# SIM$county2.x <- SIM$mi_to_county.x <- NULL
# SIM <- rename(SIM,mi_to_county = mi_to_county.y)
# SIM <- rename(SIM,county2 = county2.y)
# SIM$mi_to_county <- replace_na(SIM$mi_to_county, 500)


# Production in 2012 added to simulation data.set-----------------------

Presence <- SIM[,c("GEOID","Id_2020","Id_2028","Id_2036")]

pr_corn_2012 <- read_csv("p_corn_2012.csv", na = "(D)") %>%
  select(`State ANSI`, `County ANSI`, `Value`) %>%
  transmute(FIPS = paste0(`State ANSI`, `County ANSI`),Value) %>%
  rename(p_corn_2012 = Value)

pr_soy_2012 <- read_csv("p_soybeans_2012.csv", na = "(D)") %>%
  select(`State ANSI`, `County ANSI`, `Value`) %>%
  transmute(FIPS = paste0(`State ANSI`, `County ANSI`),Value)%>%
  rename(p_soy_2012 = Value)

pr_wheat_2012 <- read_csv("p_wheat_2012.csv", na = "(D)")%>%
  select(`State ANSI`, `County ANSI`, `Value`) %>%
  transmute(FIPS = paste0(`State ANSI`, `County ANSI`),Value)%>%
  rename(p_wheat_2012 = Value)

pr_rice_2012 <- read_csv("p_rice_2012.csv", na = "(D)")%>%
  select(`State ANSI`, `County ANSI`, `Value`) %>%
  transmute(FIPS = paste0(`State ANSI`, `County ANSI`),Value)%>%
  rename(p_rice_2012 = Value)

pr_peanuts_2012 <- read_csv("p_peanuts_2012.csv", na = "(D)")%>%
  select(`State ANSI`, `County ANSI`, `Value`) %>%
  transmute(FIPS = paste0(`State ANSI`, `County ANSI`),Value)%>%
  rename(p_peanuts_2012 = Value)

SIM <- left_join(by = c('GEOID'='FIPS'),SIM,pr_corn_2012)
SIM <- left_join(by = c('GEOID'='FIPS'),SIM,pr_soy_2012)  
SIM <- left_join(by = c('GEOID'='FIPS'),SIM,pr_wheat_2012)
SIM <- left_join(by = c('GEOID'='FIPS'),SIM,pr_rice_2012)
SIM <- left_join(by = c('GEOID'='FIPS'),SIM,pr_peanuts_2012)
#rm(pr_corn_2012,pr_soy_2012,pr_wheat_2012,pr_rice_2012,pr_peanuts_2012)

#replace NA with 0
SIM$Id_2012na <- replace_na(SIM$Id_2012, 0)
SIM$Id_2020 <- replace_na(SIM$Id_2020, 0)
SIM$New_Id_2020 <- SIM$Id_2020 - SIM$Id_2012na

SIM$Id_2028 <- replace_na(SIM$Id_2028, 0)
SIM$New_Id_2028 <- SIM$Id_2028 - SIM$Id_2020

SIM$Id_2036 <- replace_na(SIM$Id_2036, 0)
SIM$New_Id_2036 <- SIM$Id_2036 - SIM$Id_2028
# add exog shock-----
AbstractballparkS4 <- read_csv("AbstractballparkS4.txt")

#2020
SIM$draw_corn_2020 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Corn), 
                                     b=max(AbstractballparkS4$Corn),                                   c=(min(AbstractballparkS4$Corn)+max(AbstractballparkS4$Corn))/2)

SIM$EB_corn_2020 <- -1 * SIM$draw_corn_2020 * SIM$New_Id_2020

SIM$draw_soy_2020 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Soybeans), 
                                     b=max(AbstractballparkS4$Soybeans),                      c=(min(AbstractballparkS4$Soybeans)+max(AbstractballparkS4$Soybeans))/2)
SIM$EB_soy_2020 <- -1 * SIM$draw_corn_2020 * SIM$New_Id_2020

SIM$draw_wheat_2020 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Wheat), 
                                     b=max(AbstractballparkS4$Wheat),                      c=(min(AbstractballparkS4$Wheat)+max(AbstractballparkS4$Wheat))/2)
SIM$EB_wheat_2020 <- -1 * SIM$draw_wheat_2020 * SIM$New_Id_2020

SIM$draw_rice_2020 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Rice), 
                                     b=max(AbstractballparkS4$Rice),                      c=(min(AbstractballparkS4$Rice)+max(AbstractballparkS4$Rice))/2)
SIM$EB_rice_2020 <- -1 * SIM$draw_rice_2020 * SIM$New_Id_2020

SIM$draw_peanuts_2020 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Peanuts), 
                                     b=max(AbstractballparkS4$Peanuts),                      c=(min(AbstractballparkS4$Peanuts)+max(AbstractballparkS4$Peanuts))/2)
SIM$EB_peanuts_2020 <- -1 * SIM$draw_peanuts_2020 * SIM$New_Id_2020
#2028
SIM$draw_corn_2028 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Corn), 
                                     b=max(AbstractballparkS4$Corn),                                   c=(min(AbstractballparkS4$Corn)+max(AbstractballparkS4$Corn))/2)
SIM$EB_corn_2028 <- -1 * SIM$draw_corn_2028 * SIM$New_Id_2028

SIM$draw_soy_2028 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Soybeans), 
                                     b=max(AbstractballparkS4$Soybeans),                      c=(min(AbstractballparkS4$Soybeans)+max(AbstractballparkS4$Soybeans))/2)
SIM$EB_soy_2028 <- -1 * SIM$draw_corn_2028 * SIM$New_Id_2028

SIM$draw_wheat_2028 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Wheat), 
                                     b=max(AbstractballparkS4$Wheat),                      c=(min(AbstractballparkS4$Wheat)+max(AbstractballparkS4$Wheat))/2)
SIM$EB_wheat_2028 <- -1 * SIM$draw_wheat_2028 * SIM$New_Id_2028

SIM$draw_rice_2028 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Rice), 
                                     b=max(AbstractballparkS4$Rice),                      c=(min(AbstractballparkS4$Rice)+max(AbstractballparkS4$Rice))/2)
SIM$EB_rice_2028 <- -1 * SIM$draw_rice_2028 * SIM$New_Id_2028

SIM$draw_peanuts_2028 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Peanuts), 
                                     b=max(AbstractballparkS4$Peanuts),                      c=(min(AbstractballparkS4$Peanuts)+max(AbstractballparkS4$Peanuts))/2)
SIM$EB_peanuts_2028 <- -1 * SIM$draw_peanuts_2028 * SIM$New_Id_2028

#2036
SIM$draw_corn_2036 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Corn), 
                                     b=max(AbstractballparkS4$Corn),                                   c=(min(AbstractballparkS4$Corn)+max(AbstractballparkS4$Corn))/2)
SIM$EB_corn_2036 <- -1 * SIM$draw_corn_2036 * SIM$New_Id_2036

SIM$draw_soy_2036 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Soybeans), 
                                     b=max(AbstractballparkS4$Soybeans),                      c=(min(AbstractballparkS4$Soybeans)+max(AbstractballparkS4$Soybeans))/2)
SIM$EB_soy_2036 <- -1 * SIM$draw_corn_2036 * SIM$New_Id_2036

SIM$draw_wheat_2036 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Wheat), 
                                     b=max(AbstractballparkS4$Wheat),                      c=(min(AbstractballparkS4$Wheat)+max(AbstractballparkS4$Wheat))/2)
SIM$EB_wheat_2036 <- -1 * SIM$draw_wheat_2036 * SIM$New_Id_2036

SIM$draw_rice_2036 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Rice), 
                                     b=max(AbstractballparkS4$Rice),                      c=(min(AbstractballparkS4$Rice)+max(AbstractballparkS4$Rice))/2)
SIM$EB_rice_2036 <- -1 * SIM$draw_rice_2036 * SIM$New_Id_2036

SIM$draw_peanuts_2036 <- rtriangle(nrow(SIM),
                                     a=min(AbstractballparkS4$Peanuts), 
                                     b=max(AbstractballparkS4$Peanuts),                      c=(min(AbstractballparkS4$Peanuts)+max(AbstractballparkS4$Peanuts))/2)
SIM$EB_peanuts_2036 <- -1 * SIM$draw_peanuts_2036 * SIM$New_Id_2036

SIM <- select(SIM, -starts_with('draw_'))
#+++++
rm(by_cty,countyPigs,PigsIn1982,PigsIn1988,PigsIn2004,PigsIn2012,REPEAT,sf12010countydistancemiles_csv,SNOW)
h2o.shutdown(prompt = FALSE)
gc()



```

```{r}
data(continental_us_states)

map_2020 <- SIM %>%
  select(GEOID,Id_2020)%>%
  rename(region = GEOID, value = Id_2020)

map_2020$region <- as.numeric(map_2020$region)
map_2020$value <- as.factor(map_2020$value)
tabulate(map_2020$value)
county_choropleth(map_2020,
                  title = "2020 Predicted Wild Pig Presence",
                  legend = "Presence",
                  state_zoom = continental_us_states)
map_2028 <- SIM %>%
  select(GEOID,Id_2028)%>%
  rename(region = GEOID, value = Id_2028)
map_2028$region <- as.numeric(map_2028$region)
map_2028$value <- as.factor(map_2028$value)

tabulate(map_2028$value)
county_choropleth(map_2028,
                  title = "2028 Predicted Wild Pig Presence",
                  legend = "Presence",
                  state_zoom = continental_us_states)

map_2036 <- SIM %>%
  select(GEOID,Id_2036)%>%
  rename(region = GEOID, value = Id_2036)
map_2036$region <- as.numeric(map_2036$region)
map_2036$value <- as.factor(map_2036$value)

tabulate(map_2036$value)
county_choropleth(map_2036,
                  title = "2036 Predicted Wild Pig Presence",
                  legend = "Presence",
                  state_zoom = continental_us_states)




```


## Price Changes
Price changes due to the invasions are found with an equilibrium displacement model (EDM). EDM’s begin with the premise that the market in question is in equilibrium, the market is shocked, and then moves to another equilibrium (Nogueira et al. 2015; Holderieath et al. 2018; Brester, Marsh, and Atwood 2004). For each of the five crops,

$$
EP_k* \eta_{kk}^D+\sum_{j=1}^J (EP_k* \eta_{kj}^D)+s_k^{Exports} * EP_k* \eta_{kk}^{Exports}=s_k^{Imports}* EP_k*\eta_kk^{Imports}+ \sum_{fips=1}^{FIPS} (s_k^{fips} *(EP_k* \eta_{kk}^{fips}+ \sum_{j=1}^J(EP_k* \eta_{kj}^{fips})+EB_k^{fips})))
$$

are solved simultaneously with the change operator modifying the price of the commodity, $EP_k$, is used to denote the relative change of the price of commodity ($k$), elasticities ($\eta$) of demand ($D$), $exports$, $imports$, and production locations ($fips$) for own price ($kk$) and cross price elasticities ($kj$), production and consumption weights ($s$) with the same notation, and exogenous relative production shocks ($EB$). 

Elasticities are the same as used by Holderieath et al. (2018) with additional supply elasticities from FAPRI‐MU (2004). Verification of the model was conducted with unit own price elasticities and no cross price elasticities. Price changes with this set of verification elasticities are positive as expected from a restriction of supply. 

Exogenous production shocks are randomly drawn from the damage results from Anderson et al. (2016). There is substantial variation between states reported by Anderson et al. (2016) and it is not immediately apparent what states would be most alike with respect to wild pig damage drivers. There are no consumption shocks in the model, so they have been omitted for clarity. The only market level analyzed is at the farm production level, because that is where the damage occurs.

As a matter of programming pragmatism, it would be easier to solve this set of equations if it were of the form $Ax=b$. Five price changes, $x$, could be solved by in this case simplifying to a $5x5$ matrix of weighted elasticities, $A$, and a $5x1$ matrix of weighted exogenous shocks. This can be accomplished with some rearranging. 

First, the demand side for corn be expanded as an example. Notice that the domestic consumption does not have a weight. This is due to the derivation of the EDM not including a weight for domestic consumption. In practice a weight of one is assigned domestic consumtption. Second, notice that the export demand equation does not include terms for cross price elasticities. The specification of the EDM did not include cross price elasticities of export demand. In practice elasticities of zero are assigned to these cross price elasticities. Third, notice that there are no exogenous shocks included on the demand side. This was assumed in specification. In practice an exogenous shock of zero was assigned.

$$
EP_{corn}* \eta_{corn,corn}^D+\\
EP_{soy}* \eta_{corn,soy}^D+ \\
EP_{wheat}* \eta_{corn,wheat}^D+ \\
EP_{rice}* \eta_{corn,rice}^D+ \\
EP_{peanuts}* \eta_{corn,peanuts}^D+\\
s_{corn}^{Exports} * EP_{corn}* \eta_{kk}^{Exports}
$$
Then the supply side. Again, import supply is specified without a shock or cross price elasticites, however, in practice they are assigned zero values. For the sake of compactness, each county's supply is indexed by the $fips$ identifier. The county weight is distributed. 
$$
s_k^{Imports}* EP_{corn}*\eta_{corn,corn}^{Imports}+ \\
\sum_{fips=1}^{FIPS} (s_k^{fips} *EP_{corn}* eta_{kk}^{fips}+ \\
s_{corn}^{fips} *EP_{soy}* \eta_{corn,soy}^{fips})+ \\
s_{corn}^{fips} *EP_{wheat}* \eta_{corn,wheat}^{fips})+ \\
s_{corn}^{fips} *EP_{rice}* \eta_{corn,rice}^{fips})+ \\
s_{corn}^{fips} *EP_{peanuts}* \eta_{corn,peanuts}^{fips})+ \\
s_{corn}^{fips} *EB_{corn}^{fips}
)
$$
Once assembled as five very long equations without parentesis, the terms on the supply side multiplied by the $EP_k$ terms can be moved to the demand side by multiplying them by $-1$. The exogenous shocks, of zeros, for the demand side can be moved across to take up space. The numerical coefficients being multiplied by the $EP_k$ terms can be collected together by addition. Price changes are found by solving $Ax=b$ for $x$.


```{r}
# build dfs for price change calculations--------------
crops <- c("corn","soy","wheat",'rice','peanut')
markets <- c("domestic","export")
s <- SIM[,'GEOID']
suppliers <- unique(c("imports",unlist(s)))
variables <- gen_var(crops,markets,suppliers)
EB <- gen_shock(crops, place=suppliers, side = "B")
EC <- gen_shock(crops, place=markets, side = "C")
```

```{r}
# load elasticities
source('elast.R')
```

```{r}
# build elasticity of demand df------------
A1 <- as.tibble(e_domestic) %>%
  mutate(rowname = c("domestic_corn", "domestic_soy", "domestic_wheat", "domestic_rice", "domestic_peanut"))
wt_dom <- tibble(rowname = c("domestic_corn", "domestic_soy", "domestic_wheat", "domestic_rice", "domestic_peanut"),
             val = diag(w_domestic))%>%
  rename(weight = val)
dom <- left_join(wt_dom,A1, by = "rowname") 
dom <- dom[['weight']] * dom[-(1:2)]#multiply elasticities by weight 
dom
```

```{r}
# build elasticity of imports df--------------
A3 <- as.tibble(e_imports) %>%
  mutate(rowname = c("imports_corn", "imports_soy", "imports_wheat", "imports_rice", "imports_peanut"))
wt_imp <- tibble(rowname = c("imports_corn", "imports_soy", "imports_wheat", "imports_rice", "imports_peanut"),
              val = diag(ss_imports))%>%
  rename(weight = val)
imp <- left_join(wt_imp,A3, by = "rowname")
imp$weight <- -1 * imp$weight #move import supply to left side of equal sign
imp <- imp[['weight']] * imp[-(1:2)]#multiply elasticities by weight 
imp
```

```{r}
# build elasticity of exports df --------
A2 <- as.tibble(e_export) %>%
  mutate(rowname = c("export_corn", "export_soy", "export_wheat", "export_rice", "export_peanut"))

wt_exp <- tibble(rowname = c("export_corn", "export_soy", "export_wheat", "export_rice", "export_peanut"),
                 val = diag(w_export))%>%
  rename(weight = val)
exp <-  left_join(wt_exp,A2, by = "rowname")
exp <- exp[['weight']] * exp[-(1:2)]#multiply elasticities by weight 
exp
```

```{r}
# build elasticity of domestic suppliers df ------------
ve <- variables %>%
  unlist()%>%
  str_subset("\\b[e]_[:digit:]{5}.")%>%
  as.tibble()%>%
  rename(name = value)

ve$reg<- ve$name %>%
  str_replace_all("\\b[e]_(20|31)[:digit:]{3}.","e_Central_Plains_")%>%
  str_replace_all("\\b[e]_(17|18|19|29|39)[:digit:]{3}.","e_Corn_Belt_")%>%
  str_replace_all("\\b[e]_(05|22|28)[:digit:]{3}.","e_Delta_States_")%>%
  str_replace_all("\\b[e]_(04|06|08|16|30|32|35|41|49|53|56)[:digit:]{3}.","e_Far_West_")%>%
  str_replace_all("\\b[e]_(26|27|55)[:digit:]{3}.","e_Lake_States_")%>%
  str_replace_all("\\b[e]_(09|10|11|23|24|25|33|34|36|42|44|50|54)[:digit:]{3}.","e_Northeast_")%>%
  str_replace_all("\\b[e]_(38|46)[:digit:]{3}.","e_Northern_Plains_")%>%
  str_replace_all("\\b[e]_(01|12|13|21|37|45|47|51)[:digit:]{3}.","e_Southeast_")%>%
  str_replace_all("\\b[e]_(40|48)[:digit:]{3}.","e_Southern_Plains_")

temp <-   paste0(
  str_extract(ve$reg,'\\b[e]_'),
  str_extract(ve$reg,'(Central_Plains|Corn_Belt|Delta_States|Far_West|Lake_States|Northeast|Northern_Plains|Southeast|Southern_Plains)'),"['",
  str_extract(ve$reg,'(corn|soy|wheat|rice|peanut){1}'),"','",
  str_extract(ve$reg,'(corn|soy|wheat|rice|peanut)\\b'),"']"
)
ve$val <-  purrr::map_dbl(temp, eval_parse)



EBL <- tibble(EB) %>%
    rename(name = EB)%>%
    filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
    mutate(rowname = substr(name,4,18))

# rownames------------
rn <- EBL$rowname

A4_corn <- as.tibble(ve %>%
                       filter(str_detect(name, "corn_corn$"))%>% 
                       select(val) %>%
                       as_vector()) %>%
  add_column(soy = ve %>%
               filter(str_detect(name, "soy_corn$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(wheat = ve %>%
               filter(str_detect(name, "wheat_corn$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(rice = ve %>%
               filter(str_detect(name, "rice_corn$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(peanut = ve %>%
               filter(str_detect(name, "peanut_corn$"))%>% 
               select(val) %>%
               as_vector()) %>%
  rename(corn = value)%>%
  mutate(rowname = str_subset(rn,"\\b[:digit:]{5}.corn$"))
  
A4_soy <- as.tibble(ve %>%
                       filter(str_detect(name, "corn_soy$"))%>% 
                       select(val) %>%
                       as_vector()) %>%
  add_column(soy = ve %>%
               filter(str_detect(name, "soy_soy$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(wheat = ve %>%
               filter(str_detect(name, "wheat_soy$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(rice = ve %>%
               filter(str_detect(name, "rice_soy$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(peanut = ve %>%
               filter(str_detect(name, "peanut_soy$"))%>% 
               select(val) %>%
               as_vector()) %>%
  rename(corn = value)%>%
  mutate(rowname = str_subset(rn,"\\b[:digit:]{5}.soy$"))

A4_wheat <- as.tibble(ve %>%
                      filter(str_detect(name, "corn_wheat$"))%>% 
                      select(val) %>%
                      as_vector()) %>%
  add_column(soy = ve %>%
               filter(str_detect(name, "soy_wheat$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(wheat = ve %>%
               filter(str_detect(name, "wheat_wheat$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(rice = ve %>%
               filter(str_detect(name, "rice_wheat$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(peanut = ve %>%
               filter(str_detect(name, "peanut_wheat$"))%>% 
               select(val) %>%
               as_vector()) %>%
  rename(corn = value)%>%
  mutate(rowname = str_subset(rn,"\\b[:digit:]{5}.wheat$"))

A4_rice <- as.tibble(ve %>%
                      filter(str_detect(name, "corn_rice$"))%>% 
                      select(val) %>%
                      as_vector()) %>%
  add_column(soy = ve %>%
               filter(str_detect(name, "soy_rice$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(wheat = ve %>%
               filter(str_detect(name, "wheat_rice$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(rice = ve %>%
               filter(str_detect(name, "rice_rice$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(peanut = ve %>%
               filter(str_detect(name, "peanut_rice$"))%>% 
               select(val) %>%
               as_vector()) %>%
  rename(corn = value)%>%
  mutate(rowname = str_subset(rn,"\\b[:digit:]{5}.rice$"))

A4_peanut <- as.tibble(ve %>%
                      filter(str_detect(name, "corn_peanut$"))%>% 
                      select(val) %>%
                      as_vector()) %>%
  add_column(soy = ve %>%
               filter(str_detect(name, "soy_peanut$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(wheat = ve %>%
               filter(str_detect(name, "wheat_peanut$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(rice = ve %>%
               filter(str_detect(name, "rice_peanut$"))%>% 
               select(val) %>%
               as_vector())%>%
  add_column(peanut = ve %>%
               filter(str_detect(name, "peanut_peanut$"))%>% 
               select(val) %>%
               as_vector()) %>%
  rename(corn = value)%>%
  mutate(rowname = str_subset(rn,"\\b[:digit:]{5}.peanut$"))
# unweighted supply A df------------
A_dom_supply <-  bind_rows(list(A4_corn,A4_soy,A4_wheat,A4_rice,A4_peanut))
A_dom_supply
#supply weights------------
Total_Corn_Supply <- 16942000000
Total_Soy_Supply <-  4719000000 
Total_Wheat_Supply <- 3079000000
Total_Rice_Supply <- 249170000
Total_Peanut_Supply <- 8800000000

SIM$ss__corn <- SIM$p_corn_2012/Total_Corn_Supply
SIM$ss__soy <- SIM$p_soy_2012/Total_Soy_Supply
SIM$ss__wheat <- SIM$p_wheat_2012/Total_Wheat_Supply
SIM$ss__rice <- SIM$p_rice_2012/Total_Rice_Supply
SIM$ss__peanut <- SIM$p_peanuts_2012/Total_Peanut_Supply

SIM$ss__corn <- replace_na(SIM$ss__corn,0)
SIM$ss__soy <- replace_na(SIM$ss__soy,0)  
SIM$ss__wheat <- replace_na(SIM$ss__wheat,0)
SIM$ss__rice <- replace_na(SIM$ss__rice,0)
SIM$ss__peanut <- replace_na(SIM$ss__peanut,0)

tmp_Pres <- SIM %>%
  select(GEOID,ss__corn,ss__soy,ss__wheat,ss__rice,ss__peanut)

vw <-  variables %>%
  unlist() %>%
  str_subset("\\b[ss_]") %>%
  as.tibble() %>%
  rename(name = value)%>%
  filter(str_detect(name, "imports") == FALSE)

names <- vw$name
result <- list()

x <- paste0("ss__",str_extract(names,'(corn|soy|wheat|rice|peanut){1}'))
y <- str_extract(names,"[:digit:]{5}")

result <- map2_dbl(x,y,ssLookup,data=tmp_Pres)

vw <- vw %>%
  add_column(val = result)%>% 
    rename(rowname = name)%>%
  mutate(rowname = substr(rowname,4,19))

rm(Total_Corn_Supply,Total_Soy_Supply,Total_Wheat_Supply,
   Total_Rice_Supply,Total_Peanut_Supply,tmp_Pres,names,x,y,result)

#domestic supply -----------------------------------

sup_corn <- left_join(A4_corn,vw, by = "rowname")%>%
  rename(weight = val)
sup_corn$weight <- -1 * sup_corn$weight #move domestic supply to left side of equal sign
sup_corn <- sup_corn[['weight']] * sup_corn[(1:5)]#multiply elasticities by weight 
sup_corn <- summarise_all(sup_corn,sum)

sup_soy <- left_join(A4_soy,vw, by = "rowname")%>%
  rename(weight = val)
sup_soy$weight <- -1 * sup_soy$weight #move domestic supply to left side of equal sign
sup_soy <- sup_soy[['weight']] * sup_soy[(1:5)]#multiply elasticities by weight 
sup_soy <- summarise_all(sup_soy,sum)

sup_wheat <- left_join(A4_wheat,vw, by = "rowname")%>%
  rename(weight = val)
sup_wheat$weight <- -1 * sup_wheat$weight #move domestic supply to left side of equal sign
sup_wheat <- sup_wheat[['weight']] * sup_wheat[(1:5)]#multiply elasticities by weight 
sup_wheat <- summarise_all(sup_wheat,sum)


sup_rice <- left_join(A4_rice,vw, by = "rowname")%>%
  rename(weight = val)
sup_rice$weight <- -1 * sup_rice$weight #move domestic supply to left side of equal sign
sup_rice <- sup_rice[['weight']] * sup_rice[(1:5)]#multiply elasticities by weight 
sup_rice <- summarise_all(sup_rice,sum)


sup_peanut <- left_join(A4_peanut,vw, by = "rowname")%>%
  rename(weight = val)
sup_peanut$weight <- -1 * sup_peanut$weight #move domestic supply to left side of equal sign
sup_peanut <- sup_peanut[['weight']] * sup_peanut[(1:5)]#multiply elasticities by weight 
sup_peanut <- summarise_all(sup_peanut,sum)

```

```{r}
#combine into A mat------------------
A_s_corn <- dom[1,] + exp[1,] + imp[1,] + sup_corn 
A_s_soy <- dom[2,] + exp[2,] + imp[2,] + sup_soy
A_s_wheat  <- dom[3,] + exp[3,] + imp[3,] + sup_wheat 
A_s_rice <- dom[4,] + exp[4,] + imp[4,] + sup_rice
A_s_peanut <- dom[5,] + exp[5,] + imp[5,] + sup_peanut

A <- bind_rows(A_s_corn,
            A_s_soy,
            A_s_wheat,
            A_s_rice,
            A_s_peanut
            )%>%
  as.matrix()
A
```




```{r}

# build exogenous shock matrix b
# all shocks are domestic supply shocks
# because we are going with a 5x5 * 5x1 we do not need to
# evaluate other shocks as zeros to hold
# places

# production shocks -----------
#The shocks are on the production side of the equilibrium conditions. 
vws <- vw%>%
  rename(weight = val)
# 2020==================================================
EBL_2020 <- tibble(EB) %>%
  rename(name = EB)%>%
  add_column(val = c(0,SIM[,'EB_corn_2020', drop = TRUE],
                     0,SIM[,'EB_soy_2020', drop = TRUE],
                     0,SIM[,'EB_wheat_2020', drop = TRUE],
                     0,SIM[,'EB_rice_2020', drop = TRUE],
                     0,SIM[,'EB_peanuts_2020', drop = TRUE]))



b_sup_corn <- EBL_2020 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'corn\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_corn <- left_join(b_sup_corn,vws, by = 'rowname')
b_sup_corn$wtedshock <- b_sup_corn$val * b_sup_corn$weight

b_sup_soy <- EBL_2020 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'soy\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_soy <- left_join(b_sup_soy,vws, by = 'rowname')
b_sup_soy$wtedshock <- b_sup_soy$val * b_sup_soy$weight

b_sup_wheat <- EBL_2020 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'wheat\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_wheat <- left_join(b_sup_wheat,vws, by = 'rowname')
b_sup_wheat$wtedshock <- b_sup_wheat$val * b_sup_wheat$weight

b_sup_rice <- EBL_2020 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'rice\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_rice <- left_join(b_sup_rice,vws, by = 'rowname')
b_sup_rice$wtedshock <- b_sup_rice$val * b_sup_rice$weight

b_sup_peanut <- EBL_2020 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'peanut\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_peanut <- left_join(b_sup_peanut,vws, by = 'rowname')
b_sup_peanut$wtedshock <- b_sup_peanut$val * b_sup_peanut$weight
#combine into b mat------------------
shock_2020 <- 
  matrix(c(corn = sum(b_sup_corn[,5]),
            soy = sum(b_sup_soy[,5]),
            wheat = sum(b_sup_wheat[,5]),
            rice = sum(b_sup_rice[,5]),
            peanuts = sum(b_sup_peanut[,5])),nrow=5)
#2028========================================================
EBL_2028 <- tibble(EB) %>%
  rename(name = EB)%>%
  add_column(val = c(0,SIM[,'EB_corn_2028', drop = TRUE],
                     0,SIM[,'EB_soy_2028', drop = TRUE],
                     0,SIM[,'EB_wheat_2028', drop = TRUE],
                     0,SIM[,'EB_rice_2028', drop = TRUE],
                     0,SIM[,'EB_peanuts_2028', drop = TRUE]))
b_sup_corn <- EBL_2028 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'corn\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_corn <- left_join(b_sup_corn,vws, by = 'rowname')
b_sup_corn$wtedshock <- b_sup_corn$val * b_sup_corn$weight

b_sup_soy <- EBL_2028 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'soy\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_soy <- left_join(b_sup_soy,vws, by = 'rowname')
b_sup_soy$wtedshock <- b_sup_soy$val * b_sup_soy$weight

b_sup_wheat <- EBL_2028 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'wheat\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_wheat <- left_join(b_sup_wheat,vws, by = 'rowname')
b_sup_wheat$wtedshock <- b_sup_wheat$val * b_sup_wheat$weight

b_sup_rice <- EBL_2028 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'rice\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_rice <- left_join(b_sup_rice,vws, by = 'rowname')
b_sup_rice$wtedshock <- b_sup_rice$val * b_sup_rice$weight

b_sup_peanut <- EBL_2028 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'peanut\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_peanut <- left_join(b_sup_peanut,vws, by = 'rowname')
b_sup_peanut$wtedshock <- b_sup_peanut$val * b_sup_peanut$weight
#combine into b mat------------------
shock_2028 <- 
  matrix(c(corn = sum(b_sup_corn[,5]),
            soy = sum(b_sup_soy[,5]),
            wheat = sum(b_sup_wheat[,5]),
            rice = sum(b_sup_rice[,5]),
            peanuts = sum(b_sup_peanut[,5])),nrow=5)
#2036=======================================================
EBL_2036 <- tibble(EB) %>%
  rename(name = EB)%>%
  add_column(val = c(0,SIM[,'EB_corn_2036', drop = TRUE],
                     0,SIM[,'EB_soy_2036', drop = TRUE],
                     0,SIM[,'EB_wheat_2036', drop = TRUE],
                     0,SIM[,'EB_rice_2036', drop = TRUE],
                     0,SIM[,'EB_peanuts_2036', drop = TRUE]))
b_sup_corn <- EBL_2036 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'corn\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_corn <- left_join(b_sup_corn,vws, by = 'rowname')
b_sup_corn$wtedshock <- b_sup_corn$val * b_sup_corn$weight

b_sup_soy <- EBL_2036 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'soy\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_soy <- left_join(b_sup_soy,vws, by = 'rowname')
b_sup_soy$wtedshock <- b_sup_soy$val * b_sup_soy$weight

b_sup_wheat <- EBL_2036 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'wheat\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_wheat <- left_join(b_sup_wheat,vws, by = 'rowname')
b_sup_wheat$wtedshock <- b_sup_wheat$val * b_sup_wheat$weight

b_sup_rice <- EBL_2036 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'rice\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_rice <- left_join(b_sup_rice,vws, by = 'rowname')
b_sup_rice$wtedshock <- b_sup_rice$val * b_sup_rice$weight

b_sup_peanut <- EBL_2036 %>%
  filter(str_detect(name, "\\bEB_[:digit:]{5}."))%>%
  filter(str_detect(name, 'peanut\\b'))%>%
  mutate(rowname = substr(name,4,18))
b_sup_peanut <- left_join(b_sup_peanut,vws, by = 'rowname')
b_sup_peanut$wtedshock <- b_sup_peanut$val * b_sup_peanut$weight
#combine into b mat------------------
shock_2036 <- 
  matrix(c(corn = sum(b_sup_corn[,5]),
            soy = sum(b_sup_soy[,5]),
            wheat = sum(b_sup_wheat[,5]),
            rice = sum(b_sup_rice[,5]),
            peanuts = sum(b_sup_peanut[,5])),nrow=5)
```

```{r}
#solve for price changes ------------------------------
chgs_2020 <- solve(A,shock_2020)
chgs_2028 <- solve(A,shock_2028)
chgs_2036 <- solve(A,shock_2036)

```

```{r}
#new prices 
#2012 Prices from NASS
Prices <- tribble(
    ~P_2012,
    6.89,
    14.4,
    7.77,
    15.1,
    0.301
        )
Prices <- Prices %>%
    add_column(chgs_2020 = as.vector(chgs_2020))%>%
    add_column(chgs_2028 = as.vector(chgs_2028))%>%
    add_column(chgs_2036 = as.vector(chgs_2036))

Prices <- Prices %>%
    mutate(chgs_2020 = chgs_2020 + 1)%>%
    mutate(chgs_2028 = chgs_2028 + 1)%>%
    mutate(chgs_2036 = chgs_2036 + 1)

Prices <- Prices %>%
    mutate(P_2020 = P_2012 * chgs_2020)%>%
    mutate(P_2028 = P_2020 * chgs_2028)%>%
    mutate(P_2036 = P_2028 * chgs_2036)%>%
  add_column(rownames = c("corn", "soy", "wheat", "rice", "peanuts"))%>%
  column_to_rownames(var="rownames")
```

```{r}
#quantities
vet <- ve %>%
    mutate(GEOID = str_extract(name,"[:digit:]{5}"))%>%
    mutate(Var = paste0('e_',
                        str_extract(name, '(corn|soy|wheat|rice|peanut){1}'),"_",
                        str_extract(name, '(corn|soy|wheat|rice|peanut)\\b')))%>%
    select(-reg)%>%
    reshape2::dcast(GEOID ~ Var, value.var = 'val')

SIM <- left_join(SIM,vet, by = 'GEOID')


SIM$price_corn_2012 <- Prices[['corn','P_2012']]
SIM$price_soy_2012 <- Prices[['soy','P_2012']]
SIM$price_wheat_2012 <- Prices[['wheat','P_2012']]
SIM$price_rice_2012 <- Prices[['rice','P_2012']]
SIM$price_peanuts_2012 <- Prices[['peanuts','P_2012']]
SIM$price_corn_2020 <- Prices[['corn','P_2020']]
SIM$price_soy_2020 <- Prices[['soy','P_2020']]
SIM$price_wheat_2020 <- Prices[['wheat','P_2020']]
SIM$price_rice_2020 <- Prices[['rice','P_2020']]
SIM$price_peanuts_2020 <- Prices[['peanuts','P_2020']]
SIM$price_corn_2028 <- Prices[['corn','P_2028']]
SIM$price_soy_2028 <- Prices[['soy','P_2028']]
SIM$price_wheat_2028 <- Prices[['wheat','P_2028']]
SIM$price_rice_2028 <- Prices[['rice','P_2028']]


#---------------
SIM$EP_corn_2020 <- 1- Prices[['corn','chgs_2020']]
SIM$EP_soy_2020 <- 1- Prices[['soy','chgs_2020']]
SIM$EP_wheat_2020 <- 1- Prices[['wheat','chgs_2020']]
SIM$EP_rice_2020 <- 1- Prices[['rice','chgs_2020']]
SIM$EP_peanuts_2020 <- 1- Prices[['peanuts','chgs_2020']]
SIM$EP_corn_2028 <- 1- Prices[['corn','chgs_2028']]
SIM$EP_soy_2028 <- 1- Prices[['soy','chgs_2028']]
SIM$EP_wheat_2028 <- 1- Prices[['wheat','chgs_2028']]
SIM$EP_rice_2028 <- 1- Prices[['rice','chgs_2028']]
SIM$EP_peanuts_2028 <- 1- Prices[['peanuts','chgs_2028']]
SIM$EP_corn_2036 <- 1- Prices[['corn','chgs_2036']]
SIM$EP_soy_2036 <- 1- Prices[['soy','chgs_2036']]
SIM$EP_wheat_2036 <- 1- Prices[['wheat','chgs_2036']]
SIM$EP_rice_2036 <- 1- Prices[['rice','chgs_2036']]


#-----------------------


SIM$price_peanuts_2028 <- Prices[['peanuts','P_2028']]
SIM$EP_peanuts_2036 <- 1- Prices[['peanuts','chgs_2036']]
    
#-----------------------
SIM$price_corn_2036 <- Prices[['corn','P_2036']]
SIM$price_soy_2036 <- Prices[['soy','P_2036']]
SIM$price_wheat_2036 <- Prices[['wheat','P_2036']]
SIM$price_rice_2036 <- Prices[['rice','P_2036']]
SIM$price_peanuts_2036 <- Prices[['peanuts','P_2036']]

#------------------------------------------------------------

SIM$q_corn_2020 <- SIM$p_corn_2012 * (1 + (SIM$ss__corn * (SIM$e_corn_corn * SIM$EP_corn_2020)))
SIM$q_soy_2020 <- SIM$p_soy_2012 * (1 + (SIM$ss__soy * (SIM$e_soy_soy * SIM$EP_soy_2020)))
SIM$q_wheat_2020 <- SIM$p_soy_2012 * (1 + (SIM$ss__soy * (SIM$e_soy_soy * SIM$EP_soy_2020)))
SIM$q_rice_2020 <- SIM$p_soy_2012 * (1 + (SIM$ss__soy * (SIM$e_soy_soy * SIM$EP_soy_2020)))
SIM$q_peanuts_2020 <- SIM$p_soy_2012 * (1 + (SIM$ss__soy * (SIM$e_soy_soy * SIM$EP_soy_2020)))

<- SIM %>%
    add_column( = )

```


##Welfare Effects
Welfare changes are measured geometrically, discounted and summed. The sensitivity of these types of shifts to functional form is minimal, and the error imposed by using linear approximations should be acceptable so long as the changes are relatively small (Brester, Marsh, and Atwood 2004; Alston, Norton, and Pardey 1995). Welfare changes from the initial time-step to the last are discounted and summed to find total damage over the simulation period. Only long-run elasticities are used, and the adjustment is assumed to be complete within each time-step.


#Results and Discussion:

#Conclusions:


